'use strict';

var _ = require('lodash');
var async = require('async');
var mongoose = require('mongoose');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var ___default = /*#__PURE__*/_interopDefault(_);
var async__default = /*#__PURE__*/_interopDefault(async);
var mongoose__default = /*#__PURE__*/_interopDefault(mongoose);

// src/index.js

// src/sequence_archive.js
var SequenceArchive = () => {
  const sequences = /* @__PURE__ */ new Map();
  const existsSequence = (id) => sequences.has(id);
  const addSequence = (id, sequence) => {
    if (!existsSequence(id)) {
      sequences.set(id, sequence);
    }
  };
  const getSequence = (id) => sequences.get(id) || null;
  return {
    existsSequence,
    addSequence,
    getSequence
  };
};
var singleton = null;
SequenceArchive.getSingleton = () => {
  if (!singleton) {
    singleton = SequenceArchive();
  }
  return singleton;
};
var sequence_archive_default = SequenceArchive;

// src/index.js
var sequenceArchive = sequence_archive_default.getSingleton();
var Sequence;
var resolve = (path, obj) => path.split(".").reduce((prev, curr) => prev ? prev[curr] : null, obj);
function SequenceFactory(connection) {
  if (arguments.length !== 1) {
    throw new Error("Please, pass mongoose while requiring mongoose-sequence: https://github.com/ramiel/mongoose-sequence#requiring");
  }
  Sequence = function(schema, opts) {
    const defaults = {
      id: null,
      inc_field: "_id",
      start_seq: 1,
      inc_amount: 1,
      reference_fields: null,
      disable_hooks: false,
      collection_name: "counters",
      parallel_hooks: true,
      exclusive: true
    };
    const options = {
      ...defaults,
      ...opts
    };
    if (___default.default.isNull(options.reference_fields)) {
      options.reference_fields = options.inc_field;
      this._useReference = false;
    } else {
      this._useReference = true;
    }
    options.reference_fields = ___default.default.isArray(options.reference_fields) ? options.reference_fields : [options.reference_fields];
    options.reference_fields = options.reference_fields.sort();
    if (this._useReference === true && ___default.default.isNull(options.id)) {
      throw new Error("Cannot use reference fields without specifying an id");
    } else {
      options.id = options.id || options.inc_field;
    }
    this._options = options;
    this._schema = schema;
    this._counterModel = null;
  };
  Sequence.getInstance = function(schema, options) {
    const sequence = new Sequence(schema, options);
    const id = sequence.getId();
    const existsSequence = sequenceArchive.existsSequence(id);
    sequence.enable();
    if (!existsSequence) {
      sequenceArchive.addSequence(id, sequence);
    } else if (sequence._options.exclusive)
      throw new Error(`Counter already defined for field "${id}"`);
    return sequence;
  };
  Sequence.prototype.enable = function() {
    this._counterModel = this._createCounterModel();
    this._createSchemaKeys();
    this._setMethods();
    if (this._options.disable_hooks === false) {
      this._setHooks();
    }
  };
  Sequence.prototype.getId = function() {
    return this._options.id;
  };
  Sequence.prototype._getCounterReferenceField = function(doc) {
    let reference = {};
    if (this._useReference === false) {
      reference = null;
    } else {
      Object.keys(this._options.reference_fields).forEach((key) => {
        reference[this._options.reference_fields[key]] = resolve(this._options.reference_fields[key], doc);
      });
    }
    return reference;
  };
  Sequence.prototype._createSchemaKeys = function() {
    const schemaKey = this._schema.path(this._options.inc_field);
    if (___default.default.isUndefined(schemaKey)) {
      const fieldDesc = {};
      fieldDesc[this._options.inc_field] = "Number";
      this._schema.add(fieldDesc);
    } else if (schemaKey.instance !== "Number") {
      throw new Error('Auto increment field already present and not of type "Number"');
    }
  };
  Sequence.prototype._createCounterModel = function() {
    const CounterSchema = mongoose__default.default.Schema(
      {
        id: { type: String, required: true },
        reference_value: { type: mongoose__default.default.Schema.Types.Mixed, required: true },
        seq: { type: Number, default: this._options.start_seq, required: true }
      },
      {
        collection: this._options.collection_name,
        validateBeforeSave: false,
        versionKey: false,
        _id: false
      }
    );
    const modelName = `Counter_${this._options.id}`;
    if (connection.modelNames().indexOf(modelName) >= 0) {
      return connection.model(modelName);
    }
    CounterSchema.index({ id: 1, reference_value: 1 }, { unique: true });
    return connection.model(modelName, CounterSchema);
  };
  Sequence.prototype._getPreSaveHook = function() {
    const sequence = this;
    return function(next, done) {
      const doc = this;
      let cb = done;
      if (!sequence._options.parallel_hooks) {
        cb = next;
      }
      if (sequence._options.parallel_hooks) {
        next();
      }
      if (!doc.isNew) {
        cb();
        return;
      }
      sequence._createCounter(doc, (createErr, createSeq) => {
        if (createErr) {
          cb(createErr);
          return;
        }
        if (!___default.default.isNull(createSeq)) {
          doc.set(sequence._options.inc_field, createSeq);
          cb();
        } else {
          sequence._setNextCounter(doc, (setError, setSeq) => {
            if (setError) {
              cb(setError);
              return;
            }
            doc.set(sequence._options.inc_field, setSeq);
            cb();
          });
        }
      });
    };
  };
  Sequence.prototype._setHooks = function() {
    if (this._options.parallel_hooks) {
      this._schema.pre("save", true, this._getPreSaveHook());
    } else {
      this._schema.pre("save", this._getPreSaveHook());
    }
  };
  Sequence.prototype._setMethods = function() {
    this._schema.method("setNext", function(id, callback) {
      const sequence = sequenceArchive.getSequence(id);
      if (___default.default.isNull(sequence)) {
        callback(new Error(`Trying to increment a wrong sequence using the id ${id}`));
        return;
      }
      sequence._createCounter(this, (createError, createSeq) => {
        if (createError) {
          callback(createError);
          return;
        }
        if (!___default.default.isNull(createSeq)) {
          this.set(sequence._options.inc_field, createSeq);
          this.save(callback);
        } else {
          sequence._setNextCounter(this, (setError, setSeq) => {
            if (setError) {
              callback(setError);
              return;
            }
            this.set(sequence._options.inc_field, setSeq);
            this.save(callback);
          });
        }
      });
    });
    this._schema.static("counterReset", (id, reference, callback) => {
      const sequence = sequenceArchive.getSequence(id);
      sequence._resetCounter(id, reference, callback);
    });
  };
  Sequence.prototype._resetCounter = function(id, reference, callback) {
    const condition = { id };
    let cb = callback;
    let seq = 0;
    if (reference instanceof Function) {
      cb = reference;
    } else {
      condition.reference_value = this._getCounterReferenceField(reference);
    }
    if (this._options.start_seq)
      seq = this._options.start_seq - 1;
    this._counterModel.updateMany(condition, { $set: { seq } }, null, cb);
  };
  Sequence.prototype._setNextCounter = function(doc, callback) {
    const retriable = (cb) => {
      const id = this.getId();
      const referenceValue = this._getCounterReferenceField(doc);
      const incAmount = this._options.inc_amount;
      this._counterModel.findOneAndUpdate(
        { id, reference_value: referenceValue },
        { $inc: { seq: incAmount } },
        { new: true, upsert: false },
        (err, counter) => {
          if (err)
            return cb(err);
          return cb(null, counter.seq);
        }
      );
    };
    async__default.default.retry(0, retriable, callback);
  };
  Sequence.prototype._createCounter = function(doc, callback) {
    const id = this.getId();
    const referenceValue = this._getCounterReferenceField(doc);
    const startSeq = this._options.start_seq;
    const counterModel = this._counterModel;
    counterModel.findOneAndUpdate(
      {
        id,
        reference_value: referenceValue
      },
      {},
      {
        upsert: true,
        new: true,
        setDefaultsOnInsert: true,
        rawResult: true
      },
      (err, counter) => {
        if (err && err.code !== 11e3) {
          return callback(err);
        }
        if (___default.default.has(counter, "lastErrorObject") && !counter.lastErrorObject.updatedExisting) {
          return callback(null, startSeq);
        }
        return callback(null, null);
      }
    );
  };
  return Sequence.getInstance;
}

module.exports = SequenceFactory;
